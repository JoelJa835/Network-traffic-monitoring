#include <pcap.h>
#include <stdio.h>
#include <stdlib.h>
#include <netinet/ip.h>
#include <netinet/tcp.h>
#include <netinet/udp.h>

/* callback function that is executed for every packet captured */
void process_packet(u_char *args, const struct pcap_pkthdr *header, const u_char *buffer) {
  /* get the IP header */
  const struct ip *ip_header = (struct ip *)(buffer + sizeof(struct ether_header));
  
  /* get the transport layer header (TCP or UDP) */
  const struct tcphdr *tcp_header = (struct tcphdr *)(buffer + sizeof(struct ether_header) + sizeof(struct ip));
  const struct udphdr *udp_header = (struct udphdr *)(buffer + sizeof(struct ether_header) + sizeof(struct ip));

  /* check the protocol and process the packet accordingly */
  switch (ip_header->ip_p) {
    case IPPROTO_TCP:
      /* process TCP packet here */
      break;
    case IPPROTO_UDP:
      /* process UDP packet here */
      break;
    default:
      /* not a TCP or UDP packet, ignore it */
      break;
  }
}

int main(int argc, char **argv) {
  pcap_t *handle;          /* session handle */
  char *dev;               /* the device to sniff on */
  char errbuf[PCAP_ERRBUF_SIZE];  /* error buffer */

  /* check for command-line arguments */
  if (argc != 2) {
    fprintf(stderr, "Usage: %s [device]\n", argv[0]);
    return -1;
  }

  /* get the device name from the command-line arguments */
  dev = argv[1];

  /* open the session in promiscuous mode */
  handle = pcap_open_live(dev, BUFSIZ, 1, 1000, errbuf);
  if (handle == NULL) {
    fprintf(stderr, "Couldn't open device %s: %s\n", dev, errbuf);
    return -1;
  }

  /* start capturing packets */
  pcap_loop(handle, -1, process_packet, NULL);

  /* close the session */
  pcap_close(handle);

  return 0;
}

#include <pcap.h>
#include <stdio.h>
#include <stdlib.h>
#include <netinet/ip.h>
#include <netinet/tcp.h>
#include <netinet/udp.h>

/* callback function that is executed for every packet captured */
void process_packet(u_char *args, const struct pcap_pkthdr *header, const u_char *buffer) {
  /* get the IP header */
  const struct ip *ip_header = (struct ip *)(buffer + sizeof(struct ether_header));
  
  /* get the transport layer header (TCP or UDP) */
  const struct tcphdr *tcp_header = (struct tcphdr *)(buffer + sizeof(struct ether_header) + sizeof(struct ip));
  const struct udphdr *udp_header = (struct udphdr *)(buffer + sizeof(struct ether_header) + sizeof(struct ip));

  /* apply the filter expression: port 8080 */
  if (tcp_header->th_dport != 8080 && tcp_header->th_sport != 8080) {
    return;
  }

  /* check the protocol and process the packet accordingly */
  switch (ip_header->ip_p) {
    case IPPROTO_TCP:
      /* process TCP packet here */
      break;
    case IPPROTO_UDP:
      /* process UDP packet here */
      break;
    default:
      /* not a TCP or UDP packet, ignore it */
      break;
  }
}

int main(int argc, char **argv) {
  pcap_t *handle;          /* session handle */
  char *dev;               /* the device to sniff on */
  char errbuf[PCAP_ERRBUF_SIZE];  /* error buffer */

  /* check for command-line arguments */
  if (argc != 2) {
    fprintf(stderr, "Usage: %s [device]\n", argv[0]);
    return -1;
  }

  /* get the device name from the command-line arguments */
  dev = argv[1];

  /* open the session in promiscuous mode */
  handle = pcap_open_live(dev, BUFSIZ, 1, 1000, errbuf);
  if (handle == NULL) {
    fprintf(stderr, "Couldn't open device %s: %s\n", dev, errbuf);
    return -1;
  }

  /* start capturing packets */
  pcap_loop(handle, -1, process_packet, NULL);

  /* close the session */
  pcap_close(handle);

  return 0;
}



void process_tcp_packet(const u_char * Buffer, int Size)
{
	unsigned short iphdrlen;
	
	struct iphdr *iph = (struct iphdr *)( Buffer  + sizeof(struct ethhdr) );
	iphdrlen = iph->ihl*4;
	
	struct tcphdr *tcph=(struct tcphdr*)(Buffer + iphdrlen + sizeof(struct ethhdr));
			
	int header_size =  sizeof(struct ethhdr) + iphdrlen + tcph->doff*4;
	
	fprintf(logfile , "\n\n***********************TCP Packet*************************\n");	
		
	print_ip_header(Buffer,Size);
		
	fprintf(logfile , "\n");
	fprintf(logfile , "TCP Header\n");
	fprintf(logfile , "   |-Source Port      : %u\n",ntohs(tcph->source));
	fprintf(logfile , "   |-Destination Port : %u\n",ntohs(tcph->dest));
	fprintf(logfile , "   |-Sequence Number    : %u\n",ntohl(tcph->seq));
	fprintf(logfile , "   |-Acknowledge Number : %u\n",ntohl(tcph->ack_seq));
	fprintf(logfile , "   |-Header Length      : %d DWORDS or %d BYTES\n" ,(unsigned int)tcph->doff,(unsigned int)tcph->doff*4);
	//fprintf(logfile , "   |-CWR Flag : %d\n",(unsigned int)tcph->cwr);
	//fprintf(logfile , "   |-ECN Flag : %d\n",(unsigned int)tcph->ece);
	fprintf(logfile , "   |-Urgent Flag          : %d\n",(unsigned int)tcph->urg);
	fprintf(logfile , "   |-Acknowledgement Flag : %d\n",(unsigned int)tcph->ack);
	fprintf(logfile , "   |-Push Flag            : %d\n",(unsigned int)tcph->psh);
	fprintf(logfile , "   |-Reset Flag           : %d\n",(unsigned int)tcph->rst);
	fprintf(logfile , "   |-Synchronise Flag     : %d\n",(unsigned int)tcph->syn);
	fprintf(logfile , "   |-Finish Flag          : %d\n",(unsigned int)tcph->fin);
	fprintf(logfile , "   |-Window         : %d\n",ntohs(tcph->window));
	fprintf(logfile , "   |-Checksum       : %d\n",ntohs(tcph->check));
	fprintf(logfile , "   |-Urgent Pointer : %d\n",tcph->urg_ptr);
	fprintf(logfile , "\n");
	fprintf(logfile , "                        DATA Dump                         ");
	fprintf(logfile , "\n");
		
	fprintf(logfile , "IP Header\n");
	PrintData(Buffer,iphdrlen);
		
	fprintf(logfile , "TCP Header\n");
	PrintData(Buffer+iphdrlen,tcph->doff*4);
		
	fprintf(logfile , "Data Payload\n");	
	PrintData(Buffer + header_size , Size - header_size );
						
	fprintf(logfile , "\n###########################################################");
}

void process_udp_packet(const u_char *Buffer , int Size)
{
	
	unsigned short iphdrlen;
	
	struct iphdr *iph = (struct iphdr *)(Buffer +  sizeof(struct ethhdr));
	iphdrlen = iph->ihl*4;
	
	struct udphdr *udph = (struct udphdr*)(Buffer + iphdrlen  + sizeof(struct ethhdr));
	
	int header_size =  sizeof(struct ethhdr) + iphdrlen + sizeof udph;
	
	fprintf(logfile , "\n\n***********************UDP Packet*************************\n");
	
	print_ip_header(Buffer,Size);			
	
	fprintf(logfile , "\nUDP Header\n");
	fprintf(logfile , "   |-Source Port      : %d\n" , ntohs(udph->source));
	fprintf(logfile , "   |-Destination Port : %d\n" , ntohs(udph->dest));
	fprintf(logfile , "   |-UDP Length       : %d\n" , ntohs(udph->len));
	fprintf(logfile , "   |-UDP Checksum     : %d\n" , ntohs(udph->check));
	
	fprintf(logfile , "\n");
	fprintf(logfile , "IP Header\n");
	PrintData(Buffer , iphdrlen);
		
	fprintf(logfile , "UDP Header\n");
	PrintData(Buffer+iphdrlen , sizeof udph);
		
	fprintf(logfile , "Data Payload\n");	
	
	//Move the pointer ahead and reduce the size of string
	PrintData(Buffer + header_size , Size - header_size);
	
	fprintf(logfile , "\n###########################################################");
}

void PrintData (const u_char * data , int Size)
{
	int i , j;
	for(i=0 ; i < Size ; i++)
	{
		if( i!=0 && i%16==0)   //if one line of hex printing is complete...
		{
			fprintf(logfile , "         ");
			for(j=i-16 ; j<i ; j++)
			{
				if(data[j]>=32 && data[j]<=128)
					fprintf(logfile , "%c",(unsigned char)data[j]); //if its a number or alphabet
				
				else fprintf(logfile , "."); //otherwise print a dot
			}
			fprintf(logfile , "\n");
		} 
		
		if(i%16==0) fprintf(logfile , "   ");
			fprintf(logfile , " %02X",(unsigned int)data[i]);
				
		if( i==Size-1)  //print the last spaces
		{
			for(j=0;j<15-i%16;j++) 
			{
			  fprintf(logfile , "   "); //extra spaces
			}
			
			fprintf(logfile , "         ");
			
			for(j=i-i%16 ; j<=i ; j++)
			{
				if(data[j]>=32 && data[j]<=128) 
				{
				  fprintf(logfile , "%c",(unsigned char)data[j]);
				}
				else 
				{
				  fprintf(logfile , ".");
				}
			}
			
			fprintf(logfile ,  "\n" );
		}
	}
}




